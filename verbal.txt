1) Какой самый эффективный способ конкатенации строк?
    strings.Builder

2) Что такое интерфейсы, как они применяются в Go?
    структура из:
        - указателя на таблицу интерфейсов, хранящую метаданные о типе
        - список методов для удовлетворения интерфейса
    по сути это некий контракт, набор методов который должен имплементировать класс для соответствия интерфейсу
    вот такой вот полиморфизм в го

3) Чем отличаются RWMutex от Mutex?
    используя mutex, мы делаем так, чтобы только 1 горутина в единицу времени имела доступ к данным
    используя RWMutex, данные могут быть сразу в нескольких горутинах одновременно для чтения. 
    но изменение данных происходит только в одной

4) Чем отличаются буферизированные и не буферизированные каналы?
б:
    -при инициализации указываем емкость > 0
    -отправитель не блокируется если нет получателя
    -отправитель блокируется при переполнении емкость
н:
    -при инициализации не указываем емкость (указываем 0)
    -отправитель блокируется пока получатель не прочитает данные

5) Какой размер у структуры struct{}{}?
0

6) Есть ли в Go перегрузка методов или операторов?
нет

7) В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

через ренж там будет случайный порядок.
но, насколько я знаю, если мы подставляем в принт, там он может быть одинаковый (в зависимсоти от размера мапы)

8) В чем разница make и new?
нью создает указатель
мейк выделяет память и инциализирует только объекты типов: slice, map, or chan

9) Сколько существует способов задать переменную типа slice или map?
1. s := []int{1, 1, 1, 1, 1}
2. s := make([]int, 5, 5)
3. var s []int
4. s := new([]int)

1. m := map[string]int{
    "one": 1,
}
2. m := make(map[string]int)
3. m := map[string]int{}
4. m := new(map[string]int)


10) Что выведет данная программа и почему?
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
// вывод будет 1 1, т.к. в функцию передается копия указателя


11) Что выведет данная программа и почему?
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
// дедлок, т.к. вг передан не через указатель

12) Что выведет данная программа и почему?
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
// 0. в условие попадаем, но там происходит инициализация новой переменной с таким же неймингом

13) Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
// 100 2 3 4 5. строка v[0] = 100 возымеет эффект т.к. слайс - уже указатель на базовый массив
но аппенд уже никак не повлияет на происходящее в мейне, т.к. будет выделена новая память

14) Что выведет данная программа и почему?
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

// b b a
// a a
у нас слайс сразу был инициализирован с cap = 2 и len = 2
поэтому при аппенде создается новый слайс с большей емкостью и вне функции значения не меняются